
제네릭타입이란
 > 타입을 파라미터로 가지는 클래스와 인터페이스


 > 타입파라미터
  - 일반적으로 대문자 알파벳 한문자로 표현
  - 개발 코드에서는 타입 파라미터 자리에 구체적인 타입을 지정해야 한다

 > 제네릭 타입을 사용할 경우의 효과
  - object 타입을 사용하므로서 빈번한 타입 변환 발생 -> 성능 저하

멀티타입 파라미터
 > 두 개 이상의 타입 파라미터를 사용해서 선언

제네릭 메소드
 > 매개변수 타입과 리턴 타입으로 타입 파라미터를 갖는 메소드를 말한다
  - 리턴 타입 앞에 "< >" 기호를 추가하고 타입 파라미터를 기술
  - 타입 파라미터를 리턴타입과 매개변수에 사용

  public <타입파라미터,..> 리턴타입 메소드명(매개변수,..) {}

  public <T> Box<T> boxing(T t) {...}


 > 호출 방법
  - 리턴타입 변수 = <구체적 타입> 메소드명(매개값);
  - 리턴타입 변수 = 메소드명(매개값);
   
  Box<Integer> box = <Integer>boxing(100);
  Box<Integer> box = boxing(100);  //-> *


  public static <T> Box<T> boxing(T t) {}
  앞의 T 지정되는 것에 따라 결정


------------------------------------------------------------

제한된 타입 파라미터
 타입 파라미터에 지정되는 구체적인 타입을 제한할 필요가 있을 경우

 > 상속 및 구현 관계를 이용해서 타입을 제한

 public <T extends 상위타입> 리턴타입 메소드(매개변수, ..) {..}

  - 상위 타입은 클래스 뿐만 아니라 인터페이스도 가능하다
    (인터페이스라고해서 extends 대신 implements 를 사용하지 않는다)

 > 타입 파라미터를 대체할 구체적인 타입
  - 상위타입이거나 하위 또는 구현 클래스만 지정할 수 있다

 > 주의할 점 *
  - 메소드의 중괄호 {} 안에서 타입 파라미터 변수로 사용 가능한 것은
    상위 타입의 멤버(필드, 메소드) 로 제한된다

  - 하위 타입에만 있는 필드와 메소드는 사용할 수 없다

 => 상위타입도 올 수 있으므로 하위에만 있는 것은 안된다는..
    -------------------------------------------------------
------------------------------------------------------------

와일드카드 타입

 > 제네릭 타입을 매개변수나 리턴타입으로 사용할 때
   타입 파라미터를 제한할 목적

   
   publi static void registerCourse(Course<?> course) {

   publi static void registerCourseStudent(Course<? extends Student> course) {

   publi static void registerCourseStudent(Course<? super Worker> course) {


  - 제네릭타입<?> : Unbounded Wildcards (제한없음)

  - 제네릭타입<? extends 상위타입> : Upper Bounded Wildcards (상위 클래스 제한)

    C 를 넣었다 가정 C, D, E 올 수 있다, A, B 는 못옴

  - 제네릭타입<? super 하위타입> : Lower Bounded Wildcards (하위 클래스 제한)

    C 를 넣었다 가정 A, B, C 올 수 있다, D, E 는 못옴 
 A
 ↑
 B
 ↑
 C
 ↑
 D
 ↑
 E
(상속 관계)
********************
